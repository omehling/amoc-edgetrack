
include("../edge_tracking/gottwald_model_noice.jl")

using DynamicalSystemsBase
using DelayEmbeddings: Dataset
using ChaosTools
using OrdinaryDiffEq
using Statistics
using Dates
using Random
using Printf
using HDF5: h5open
using LinearAlgebra: norm

####### Model arguments and defs #######
# G21 model (no ice) with scaling of (x,y,z)
sys2(u,p,t) = gottwald_noice_scaled(u,p,t;stochsys=false)
scale = 5000.
# Parameters
p_default = param_gwn_default()
p_scaled = zeros(length(p_default)+1)
p_scaled[1:end-1]=p_default[:]
p_scaled[7]=0.1 # F1
p_scaled[5]=3e-4 # epsilon_f
p_scaled[end]=scale
# Initialization and time-stepping
u1 = [2.,1.,0.,1.5,0.5]./[scale, scale, scale, 1., 1.]
u2 = [1., 0., 2., 1.5, 1.125]./[scale, scale, scale, 1., 1.]
diffeq_args = (alg = DP5(), adaptive=false, dt=7.5e-6)
spinup_steps = 300000

function ds_fw(fw)
    p_fw = deepcopy(p_scaled)
    p_fw[12] = fw
    return ContinuousDynamicalSystem(sys2, u1, p_fw)
end

function attractors_fw(fw; t_tot = 200., spinup = 70., diffeq = NamedTuple(), Δt=diffeq.dt*10)
    ds_mod = ds_fw(fw)
    
    sol_u1_mod = trajectory(ds_mod, t_tot, u1, Ttr=spinup, Δt=Δt, diffeq = diffeq) # q > 0
    sol_u2_mod = trajectory(ds_mod, t_tot, u2, Ttr=spinup, Δt=Δt, diffeq = diffeq) # q < 0
    
    return sol_u1_mod, sol_u2_mod
end

function load_edge(fw; subdir = "../edge_tracking/")
    filename = @sprintf("edgetrack_L84stommel_sig%04d.h5", fw*1000)
    
    # Load computed edge state from hdf5 file -> generated by edgetrack_L84stommel_sigma.jl
    u_edge = h5open(subdir * filename, "r") do file
        read(file, "u_edge")
    end
    t_edge = h5open(subdir * filename, "r") do file
        read(file, "t")
    end
    return t_edge, u_edge
end


####### Definitions for attractor section #######
function edge_section_state(e, minstate, maxstate)
    (maxstate-minstate).*e + minstate
end

# Ensemble of trajectories for final state sensitivity
function attr_along_line_trajs(ds, u1, u2, N_section, Tmax; eps_boundary=0., Δt_write = 1., diffeq = NamedTuple())
    init_pinteg_section = [edge_section_state(e, u1, u2) for e in LinRange(-eps_boundary, 1+eps_boundary, N_section)]
    pinteg_section = parallel_integrator(ds, init_pinteg_section; diffeq = diffeq);
    
    t_prev = -1
    t_curr = 0
    i = 1
    Nwrites = Int(ceil(Tmax/Δt_write))
    section_div_trajs = zeros(Nwrites, size(init_pinteg_section)[1], dimension(ds))
    section_div_t = zeros(Nwrites)
    while t_curr < Tmax
        t_prev = pinteg_section.t
        step!(pinteg_section)
        t_curr = pinteg_section.t
        if (t_curr % Δt_write) < (t_prev % Δt_write)
            # write output every Δt_write steps
            section_div_trajs[i,:,:] = reduce(hcat,get_states(pinteg_section))'
            section_div_t[i] = t_curr
            i+=1
        end
    end
    
    return section_div_t, section_div_trajs
end

# Attractor number for each trajectory of the ensemble
function attr_along_line_trajs_nos(section_div_trajs, mean_a1, mean_a2)
    N_section = size(section_div_trajs)[2]
    attr_nos_section = zeros(N_section)
    for j in 1:N_section
        ST_mean = section_div_trajs[end,j,4:5]
        attr_nos_section[j] = argmin([norm(ST_mean-mean_a1), norm(ST_mean-mean_a2)])
    end
    return attr_nos_section
end

# Find two random initial conditions in two different basins (sped up by using the Stommel basins)
function rand_inits_stommel_basins(basins_stommel, grid_stommel, mapper_coupled)
    grid_size = [0, 0]
    grid_size[1] = size(grid_stommel[1])[1]
    grid_size[2] = size(grid_stommel[2])[1]
    rand1_fullattr = 0
    rand2_fullattr = 0
    u1_rnd = zeros(5)
    u2_rnd = zeros(5)
    while rand1_fullattr == rand2_fullattr
        coord_rand1 = (0,0)
        coord_rand2 = (0,0)
        rand1_attr = 0
        rand2_attr = 0
        while (rand1_attr != 1) || (rand2_attr != 2)
            coord_rand1 = (rand(1:grid_size[1]), rand(1:grid_size[2]))
            coord_rand2 = (rand(1:grid_size[1]), rand(1:grid_size[2]))
            rand1_attr = basins_stommel[coord_rand1[1], coord_rand1[2]]
            rand2_attr = basins_stommel[coord_rand2[1], coord_rand2[2]]
        end
        u1_rnd = [rand()*2/scale, rand()*2/scale, rand()*2/scale, grid_stommel[1][coord_rand1[1]], grid_stommel[2][coord_rand1[2]]]
        u2_rnd = [rand()*2/scale, rand()*2/scale, rand()*2/scale, grid_stommel[1][coord_rand2[1]], grid_stommel[2][coord_rand2[2]]]
        rand1_fullattr, rand2_fullattr = mapper_coupled(u1_rnd), mapper_coupled(u2_rnd)
    end
    return u1_rnd, u2_rnd
end

function bisect_to_edge(pinteg, mapper::AttractorMapper; abstol=1e-9)
    u1, u2 = get_states(pinteg)
    idx1, idx2 = mapper(u1), mapper(u2)

    if idx1 == idx2
        error("Both initial conditions belong to the same basin of attraction.")
    end

    distance = norm(u1-u2)
    while distance > abstol
        u_new = (u1 + u2)/2
        idx_new = mapper(u_new)

        if idx_new == idx1
            u1 = u_new
        else
            u2 = u_new
            if idx_new != idx2
                @warn "New bisection point belongs to a third basin of attraction."
            end
        end
        distance = norm(u1-u2)
    end
    [u1, u2]
end
####### End of definitions #######

# Command line argument
fw_sel = tryparse(Float64,ARGS[1])
if isnothing(fw_sel) == true
    throw(ArgumentError(
        @sprintf("Value for fw_sel provided to script (%s) cannot be converted to Float64", ARGS[1])
    ))
end

# Global arguments for script
#fw_sel = 0.9 # freshwater parameter (sigma_0)
abstol_init = 1e-3 # length of cross-boundary sections
N_sects = 10 # number of sections
N_inits = 8192 # number of initial conditions per section
Tmax_sect = 15 # integration time for convergence to attractors

# Equivalent Stommel model
ds_stommel = ContinuousDynamicalSystem(
    stommel_gottwald, [1.,1.],
    [[p_default[3], p_default[4], p_default[10], fw_sel]]
)

t_edge_sel, u_edge_sel = load_edge(fw_sel)
ds_mod = ds_fw(fw_sel)
sol_u1_sel, sol_u2_sel = attractors_fw(fw_sel; t_tot = 100., spinup = 20., diffeq = diffeq_args, Δt=diffeq_args.dt*100)
mean_a1 = mean(Matrix(sol_u1_sel), dims=1)[4:5]
mean_a2 = mean(Matrix(sol_u2_sel), dims=1)[4:5]
attrs = Dict(1 =>Dataset([mean(sol_u1_sel.data)]), 2 => Dataset([mean(sol_u2_sel.data)]))

# Basins of attraction for Stommel model
iv = 0..2
grid_size = 101
fp_stommel, eigs_stommel, stable_stommel = fixedpoints(ds_stommel, iv × iv)
stable_idx = []; unstable_idx = []
for i = 1:length(stable_stommel)
    if stable_stommel[i] == 1
        append!(stable_idx, i)
    else
        append!(unstable_idx, i)
    end
end
mapper_stommel_dist = min(
    norm(fp_stommel[stable_idx[1]]-fp_stommel[unstable_idx[1]]),
    norm(fp_stommel[stable_idx[2]]-fp_stommel[unstable_idx[1]])
)*0.8
attrs_stommel = Dict(1 => Dataset([fp_stommel.data[stable_idx[1]]]), 2 => Dataset([fp_stommel.data[stable_idx[2]]]))
mapper_stommel = AttractorsViaProximity(ds_stommel, attrs_stommel, mapper_stommel_dist, maxit=200, mx_chk_lost=10000)
grid_stommel = (range(-1, 2; length = grid_size), range(-1, 2; length = grid_size))
basins_stommel, _ = basins_of_attraction(mapper_stommel, grid_stommel)

println("Basin 1: ", sum(basins_stommel.==1), " points, Basin 2: ", sum(basins_stommel.==2))

maxstate = vec(maximum(Matrix(u_edge_sel[spinup_steps:end,:]); dims=1))
minstate = vec(minimum(Matrix(u_edge_sel[spinup_steps:end,:]); dims=1))
mapper = AttractorsViaProximity(ds_mod, attrs, mapper_stommel_dist*1.25; diffeq = diffeq_args, Δt=1, maxit=200, mx_chk_lost=10000)

println("Finished initializing, starting section across saddle...")

n = 0
# Section through the saddle
section_saddle_t, section_saddle_trajs = attr_along_line_trajs(
    ds_mod, minstate, maxstate, N_inits, Tmax_sect;
    eps_boundary=0.15, Δt_write = 0.001, diffeq = diffeq_args
)
attr_sec_saddle = attr_along_line_trajs_nos(section_saddle_trajs, mean_a1, mean_a2)

h5open(@sprintf("bb_traj_sig%04d_N%02d.h5", fw_sel*1000, n), "w") do file
    write(file, "t", convert(Array{Float32}, section_saddle_t))
    write(file, "u", convert(Array{Float32}, section_saddle_trajs))
    write(file, "attr_no", convert(Array{Int8}, attr_sec_saddle))
end
println("Finished section across saddle")

for n = 1:N_sects
    # Random initial conditions
    u1_rnd, u2_rnd = rand_inits_stommel_basins(basins_stommel, grid_stommel, mapper)
    # Bisect to find ICs close to the basin boundary
    pinteg_bisect = parallel_integrator(ds_mod, [u1_rnd, u2_rnd]; diffeq = diffeq_args)
    u1_bisect, u2_bisect = bisect_to_edge(pinteg_bisect, mapper; abstol = abstol_init)

    # Attractors along section
    section_bisect_t, section_bisect_trajs = attr_along_line_trajs(
        ds_mod, u1_bisect, u2_bisect, N_inits, Tmax_sect;
        eps_boundary=0., Δt_write = 0.001, diffeq = diffeq_args
    )
    attr_sec_bisect = attr_along_line_trajs_nos(section_bisect_trajs, mean_a1, mean_a2)

    # Save to file
    h5open(@sprintf("bb_traj_sig%04d_N%02d.h5", fw_sel*1000, n), "w") do file
        write(file, "t", convert(Array{Float32}, section_bisect_t))
        write(file, "u", convert(Array{Float32}, section_bisect_trajs))
        write(file, "attr_no", convert(Array{Int8}, attr_sec_bisect))
    end
    println("Finished section ", n, " across basin boundary")
end
