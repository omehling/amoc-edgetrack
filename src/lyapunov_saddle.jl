include("model_definitions.jl")

using DynamicalSystemsBase
using DelayEmbeddings: Dataset
using ChaosTools
using OrdinaryDiffEq

using Statistics
using ProgressMeter
using Dates
using Random
using Printf
using HDF5: h5open
using LinearAlgebra: norm
using DataFrames, CSV

### Model definition

# G21 model (no ice) with scaling of (x,y,z)
sys2(u,p,t) = gottwald_noice_scaled(u,p,t;stochsys=false)
scale = 5000.
# Parameters
sigma_0 = 0.8
p_default = param_gwn_default()
p_scaled = zeros(length(p_default)+1)
p_scaled[1:end-1]=p_default[:]
p_scaled[7]=0.1 # F1
p_scaled[5]=3e-4 # epsilon_f
p_scaled[12]=sigma_0  # freshwater flux, cmd line argument
p_scaled[end]=scale
# Initialize ds
u1=[2.,1.,0.,1.5,0.5]./[scale, scale, scale, 1., 1.]
u2=[1., 0., 2., 1.5, 1.125]./[scale, scale, scale, 1., 1.]
ds_default = ContinuousDynamicalSystem(sys2, u1, p_scaled)

# Timestepping arguments
diffeq_args = (alg = DP5(), adaptive=false, dt=7.5e-6)


### Functions

function ds_fw(fw)
    p_fw = deepcopy(p_scaled)
    p_fw[12] = fw
    return ContinuousDynamicalSystem(sys2, u1, p_fw)
end

function attractors_fw(fw; t_tot = 200., spinup = 70., diffeq = NamedTuple(), Δt=diffeq.dt*10)
    ds_mod = ds_fw(fw)
    
    sol_u1_mod = trajectory(ds_mod, t_tot, u1, Ttr=spinup, Δt=Δt, diffeq = diffeq) # q > 0
    sol_u2_mod = trajectory(ds_mod, t_tot, u2, Ttr=spinup, Δt=Δt, diffeq = diffeq) # q < 0
    
    return sol_u1_mod, sol_u2_mod
end

function load_edge(fw; subdir = "./")
    filename = @sprintf("edgetrack_L84stommel_sig%04d.h5", fw*1000)
    
    # Load computed edge state from hdf5 file -> generated by edgetrack_L84stommel_sigma.jl
    u_edge = h5open(subdir * filename, "r") do file
        read(file, "u_edge")
    end
    u_track1 = h5open(subdir * filename, "r") do file
        read(file, "u_track1")
    end
    u_track2 = h5open(subdir * filename, "r") do file
        read(file, "u_track2")
    end
    t_edge = h5open(subdir * filename, "r") do file
        read(file, "t")
    end
    return t_edge, u_edge, u_track1, u_track2
end

# From CriticalTransitions.jl
function intervals_to_box(bmin::Vector, bmax::Vector)
    # Generates a box from specifying the interval limits
    intervals = []
    dim = length(bmin)
    for i in 1:dim
        push!(intervals, bmin[i]..bmax[i])
    end
    box = intervals[1]
    for i in 2:dim
        box = box × intervals[i]
    end
    box
end

# Lifetime of individual (near-)saddle trajectory
function calc_tau_saddle(integ_transient, Δt_sample, Tmax, saddle_bbox; τ_break=1000*Δt_sample)
    τ_transient = 0.
    τ_outside = 0.
    t0 = integ_transient.t
    while integ_transient.t < Tmax
        step!(integ_transient, Δt_sample)
        # Check whether state is on transient "attractor"
        if (get_state(integ_transient) in saddle_bbox)
            τ_transient += (integ_transient.t - t0)
        else
            τ_outside += (integ_transient.t - t0)
        end
        if τ_outside >= τ_break
            return τ_transient
        end
        # Update for next step
        t0 = integ_transient.t
    end
    return τ_transient
end

# Lifetimes of ensemble of (near-)saddle trajectories
function calc_tau_saddle(
    ds_mod, tr_inits, Δt_sample, Tmax, saddle_bbox;
    diffeq_args = NamedTuple(), τ_break=1000*Δt_sample
)
    Ninits = length(tr_inits)
    τ_transients = zeros(Ninits)
    integ_transient = integrator(ds_mod, tr_inits[1]; diffeq = diffeq_args)
    @showprogress for i = 1:Ninits
        reinit!(integ_transient, tr_inits[i])
        τ_transients[i] = calc_tau_saddle(integ_transient, Δt_sample, Tmax, saddle_bbox; τ_break=τ_break)
    end
    return τ_transients
end

function lyapunovspectrum_ensemble(ds, inits, Tmax_qr::AbstractVector, Δt_qr; Ttr=0., Ttr_qr=1., diffeq_args = NamedTuple())
    N_inits = length(inits)
    lyapunovspecs = zeros(N_inits, dimension(ds))
    if (Ttr > 0) integ_spinup = integrator(ds_mod, inits[1,:]; diffeq = diffeq_args) end
    @showprogress for i = 1:N_inits
        u_init = inits[i]
        if Ttr > 0
            reinit!(integ_spinup, u_init)
            step!(integ_spinup, Ttr)
            u_init = get_state(integ_spinup)
        end
        N_qr = Int(round(Tmax_qr[i]/Δt_qr))
        lyapunovspecs[i,:] = lyapunovspectrum(ds_mod, N_qr;
            u0 = u_init, Δt=Δt_qr, Ttr=Ttr_qr, diffeq = diffeq_args)
    end
    return lyapunovspecs
end

function lyapunovspectrum_ensemble(ds, inits, Tmax_qr::Number, Δt_qr; Ttr=0., Ttr_qr=1., diffeq_args = NamedTuple())
    Tmax_qr_vec = [Tmax_qr for i=1:length(inits)]
    lyapunovspectrum_ensemble(ds, inits, Tmax_qr_vec, Δt_qr; Ttr=Ttr, Ttr_qr=Ttr_qr, diffeq_args = diffeq_args)
end


### Main

fw_sel = tryparse(Float64,ARGS[1])
if isnothing(fw_sel) == true
    throw(ArgumentError(
        @sprintf("Value for sigma provided to script (%s) cannot be converted to Float64", ARGS[1])
    ))
end
ds_mod = ds_fw(fw_sel)
sol_u1_sel, sol_u2_sel = attractors_fw(fw_sel; t_tot = 100., spinup = 20., diffeq = diffeq_args, Δt=diffeq_args.dt*1000)
t_edge_sel, u_edge_sel, _, _ = load_edge(fw_sel)
mean_a1 = mean(Matrix(sol_u1_sel), dims=1)[4:5]
mean_a2 = mean(Matrix(sol_u2_sel), dims=1)[4:5]

# Sample initial conditions from attractors
N_sample_attr = 100
init_sample_u1 = [sol_u1_sel[i,:] for i = 1:Int(ceil(size(sol_u1_sel)[1]/N_sample_attr)):size(sol_u1_sel)[1]]
init_sample_u2 = [sol_u2_sel[i,:] for i = 1:Int(ceil(size(sol_u2_sel)[1]/N_sample_attr)):size(sol_u2_sel)[1]]

# Finite-size Lyapunov spectra of attractors from N_sample_attr samples
lyaspec_u1 = lyapunovspectrum_ensemble(ds_mod, init_sample_u1, 7.5, diffeq_args.dt*100;
    Ttr=0., Ttr_qr=1., diffeq_args = diffeq_args
)
lyaspec_u2 = lyapunovspectrum_ensemble(ds_mod, init_sample_u2, 7.5, diffeq_args.dt*100;
    Ttr=0., Ttr_qr=1., diffeq_args = diffeq_args
)

# Calculate lifetimes of saddle
spinup_steps_saddle = 300000
starts_mod = spinup_steps_saddle:20000:size(u_edge_sel)[1]
edgestate_box_mod = intervals_to_box(
    vec(minimum(Matrix(u_edge_sel[spinup_steps_saddle:end,:]); dims=1)),
    vec(maximum(Matrix(u_edge_sel[spinup_steps_saddle:end,:]); dims=1))
)
starts_mod_lya = spinup_steps_saddle:1000:size(u_edge_sel)[1]
inits_lya_saddle = [u_edge_sel[i,:] for i in starts_mod_lya]
lifetimes_saddle = calc_tau_saddle(ds_mod, inits_lya_saddle, diffeq_args.dt*10, 100., edgestate_box_mod;
    diffeq_args = diffeq_args, τ_break = diffeq_args.dt*1e4
)

# Select longest saddle-tracking trajectories
τ_cutoff = quantile(lifetimes_saddle, .98)
long_inits = inits_lya_saddle[lifetimes_saddle.>τ_cutoff]
τ_long_inits = lifetimes_saddle[lifetimes_saddle.>τ_cutoff]

# Lyapunov spectrum of saddle
lyaspec_saddle = lyapunovspectrum_ensemble(ds_mod, long_inits, τ_long_inits, diffeq_args.dt*100;
    Ttr=0., Ttr_qr=1., diffeq_args = diffeq_args
)

println("u1:     ", vec(mean(lyaspec_u1, dims=1)),
      "\nu2:     ", vec(mean(lyaspec_u2, dims=1)),
      "\nSaddle: ", vec(mean(lyaspec_saddle, dims=1)))

h5open(@sprintf("lyapunov_spectrum_sig%04d.h5", fw_sel*1000), "w") do file
    write(file, "lyapunov_u1", lyaspec_u1)
    write(file, "lyapunov_u2", lyaspec_u2)
    write(file, "tau_saddle", τ_long_inits)
    write(file, "lyapunov_saddle", lyaspec_saddle)
end
